/*
 * API Inventory
 *
 * This is the Challenge API
 *
 * API version: 1.0.0
 * Contact: maxmonte.vix@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
//package swagger

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

//=============================================================================================
// TEST DATA

//============================================================================================
// TEST

var projetos = Projects{

	{
		Name:        "prj1",
		DisplayName: "Project_1",
		Description: " Projeto da equipe 1",
		CreateTime:  time.Now(),
		UpdateTime:  time.Now(),
		Apis:        []ApiItem{},
	},
	{
		Name:        "prj2",
		DisplayName: "Project_2",
		Description: " Projeto da equipe 2",
		CreateTime:  time.Now(),
		UpdateTime:  time.Now(),
		Apis:        []ApiItem{},
	},
	{
		Name:        "prj3",
		DisplayName: "Project_3",
		Description: " Projeto da equipe 3",
		CreateTime:  time.Now(),
		UpdateTime:  time.Now(),
		Apis:        []ApiItem{},
	},
}

var url string = "mongodb+srv://developer:Devveloper@cluster0.4fxmc.mongodb.net/myFirstDatabase?retryWrites=true&w=majority"

//DB functions=============================================================================================

func LoadDB(url, db, colec string) {

	// Set client options
	//clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	clientOptions := options.Client().ApplyURI(url)

	// Connect to MongoDB
	client, err := mongo.Connect(context.TODO(), clientOptions)

	if err != nil {
		log.Fatal(err)
	}

	// Check the connection
	err = client.Ping(context.TODO(), nil)

	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Connected to MongoDB!")
	connection := client.Database(db).Collection(colec)

	var prb_1 bson.M = bson.M{
		"Name":        "prj1",
		"DisplayName": "Project_1",
		"Description": " Projeto da equipe 1",
		"CreateTime":  time.Now(),
		"UpdateTime":  time.Now(),
		"Apis":        []ApiItem{},
	}
	var prb_2 bson.M = bson.M{
		"Name":        "prj2",
		"DisplayName": "Project_2",
		"Description": " Projeto da equipe 2",
		"CreateTime":  time.Now(),
		"UpdateTime":  time.Now(),
		"Apis":        []ApiItem{},
	}
	var prb_3 bson.M = bson.M{
		"Name":        "prj3",
		"DisplayName": "Project_3",
		"Description": " Projeto da equipe 3",
		"CreateTime":  time.Now(),
		"UpdateTime":  time.Now(),
		"Apis":        []ApiItem{},
	}

	var prb_4 bson.M = bson.M{
		"Name":        "prj4",
		"DisplayName": "Project_4",
		"Description": " Projeto da equipe 4",
		"CreateTime":  time.Now(),
		"UpdateTime":  time.Now(),
		"Apis":        []ApiItem{},
	}
	var prb_5 bson.M = bson.M{
		"Name":        "prj5",
		"DisplayName": "Project_5",
		"Description": " Projeto da equipe 5",
		"CreateTime":  time.Now(),
		"UpdateTime":  time.Now(),
		"Apis":        []ApiItem{},
	}
	var prb_6 bson.M = bson.M{
		"Name":        "prj6",
		"DisplayName": "Project_6",
		"Description": " Projeto da equipe 6",
		"CreateTime":  time.Now(),
		"UpdateTime":  time.Now(),
		"Apis":        []ApiItem{},
	}

	var prjs [6]bson.M

	prjs[0] = prb_1
	prjs[1] = prb_2
	prjs[2] = prb_3
	prjs[3] = prb_4
	prjs[4] = prb_5
	prjs[5] = prb_6

	for i := 0; i < len(prjs); i++ {
		insertResult, err := connection.InsertOne(context.TODO(), prjs[i])
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("Inserted a single document: %v \n", insertResult.InsertedID)
	}

}

func inserProjecttDB(url, db, colec string, prj ProjectItem) bson.M {

	// Set client options
	//clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	clientOptions := options.Client().ApplyURI(url)

	// Connect to MongoDB
	client, err := mongo.Connect(context.TODO(), clientOptions)

	if err != nil {
		log.Fatal(err)
	}

	// Check the connection
	err = client.Ping(context.TODO(), nil)

	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Connected to MongoDB!")

	connection := client.Database(db).Collection(colec)
	var new_prj bson.M = bson.M{
		"Name":        prj.Name,
		"DisplayName": prj.DisplayName,
		"Description": prj.Description,
		"CreateTime":  prj.CreateTime,
		"UpdateTime":  time.Now(),
		"Apis":        prj.Apis,
	}

	//searche before insert
	var filter bson.M
	filter = bson.M{"Name": prj.Name}

	filterCursor, err := connection.Find(context.TODO(), filter)
	if err != nil {
		log.Fatal(err)
	}
	var projectssFiltered []bson.M
	if err = filterCursor.All(context.TODO(), &projectssFiltered); err != nil {
		log.Fatal(err)
	}

	if len(projectssFiltered) == 0 {
		insertResult, err := connection.InsertOne(context.TODO(), new_prj)
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("Inserted a single document: %v \n", insertResult.InsertedID)
	}
	return new_prj

}

func searchProjecttDB(url, db, colec, prjname, apiname string, prj ProjectItem, all bool) mongo.Cursor {

	// Set client options
	//clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	clientOptions := options.Client().ApplyURI(url)

	// Connect to MongoDB
	client, err := mongo.Connect(context.TODO(), clientOptions)

	if err != nil {
		log.Fatal(err)
	}

	// Check the connection
	err = client.Ping(context.TODO(), nil)

	var resp *mongo.Cursor

	if err != nil {
		log.Fatal(err)
	}

	connection := client.Database(db).Collection(colec)
	if all {

		cursor, err := connection.Find(context.TODO(), bson.M{})
		if err != nil {
			log.Fatal(err)
		}

		var projects []bson.M
		if err = cursor.All(context.TODO(), &projects); err != nil {
			log.Fatal(err)
		}
		connection.Database().Client().Disconnect(context.TODO())
		resp = cursor
		log.Printf(" Projects: %v\n", projects)

	} else {

		var filter bson.M
		filter = bson.M{"Name": string(prjname)}

		filterCursor, err := connection.Find(context.TODO(), filter)
		if err != nil {
			log.Fatal(err)
		}
		var projectssFiltered []bson.M
		if err = filterCursor.All(context.TODO(), &projectssFiltered); err != nil {
			log.Fatal(err)
		}
		resp = filterCursor

		log.Printf(" ProjectsFiltered: %v\n", projectssFiltered)
		connection.Database().Client().Disconnect(context.TODO())

	}

	return *resp

}

//===================================================================================================================================

func deleteProjecttDB(url, db, colec, prjname, apiname string, prj ProjectItem) bool {

	clientOptions := options.Client().ApplyURI(url)

	// Connect to MongoDB
	client, err := mongo.Connect(context.TODO(), clientOptions)

	if err != nil {
		log.Fatal(err)
	}

	// Check the connection
	err = client.Ping(context.TODO(), nil)

	if err != nil {
		log.Fatal(err)
	}
	connection := client.Database(db).Collection(colec)

	//searche before delete
	var filter bson.M
	filter = bson.M{"Name": prj.Name}

	filterCursor, err := connection.Find(context.TODO(), filter)
	if err != nil {
		log.Fatal(err)
	}
	var projectssFiltered []bson.M
	if err = filterCursor.All(context.TODO(), &projectssFiltered); err != nil {
		log.Fatal(err)
	}

	if len(projectssFiltered) != 0 {
		insertResult, err := connection.DeleteOne(context.TODO(), filter)
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("Deleted a single document: %v \n", insertResult.DeletedCount)

	}

	log.Printf("Project Deleted")
	connection.Database().Client().Disconnect(context.TODO())
	return true

}

func updateProjecttDB(url, db, colec, prjname, apiname string, prj ProjectItem) bson.M {

	// Set client options
	//clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	clientOptions := options.Client().ApplyURI(url)

	// Connect to MongoDB
	client, err := mongo.Connect(context.TODO(), clientOptions)

	if err != nil {
		log.Fatal(err)
	}

	// Check the connection
	err = client.Ping(context.TODO(), nil)

	if err != nil {
		log.Fatal(err)
	}

	connection := client.Database(db).Collection(colec)

	var new_prj bson.M = bson.M{
		"Name":        prj.Name,
		"DisplayName": prj.DisplayName,
		"Description": prj.Description,
		"CreateTime":  prj.CreateTime,
		"UpdateTime":  time.Now(),
		"Apis":        prj.Apis,
	}

	//searche before delete
	var filter bson.M
	filter = bson.M{"Name": prj.Name}

	filterCursor, err := connection.Find(context.TODO(), filter)
	if err != nil {
		log.Fatal(err)
	}
	var projectssFiltered []bson.M
	if err = filterCursor.All(context.TODO(), &projectssFiltered); err != nil {
		log.Fatal(err)
	}

	if len(projectssFiltered) != 0 {
		insertResult, err := connection.UpdateOne(context.TODO(), filter, new_prj)
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("Updated a single document: %v \n", insertResult.ModifiedCount)

	}

	log.Printf("Project Updated")
	connection.Database().Client().Disconnect(context.TODO())
	return new_prj

}

// Index ===============================================================================

func Index(w http.ResponseWriter, r *http.Request) {

	var pr ProjectItem
	fmt.Fprintf(w, "<h1>Hello Desafio!")
	log.Printf(" Index hit")

	//LoadDB(url, "Desafio", "Projects")
	searchProjecttDB(url, "Desafio", "Projects", "prj3", "", pr, false)

	w.WriteHeader(http.StatusOK)

}

/*********************************************************************************************************************************************
*       API  Handles
*
***********************************************************************************************************************************************
 */

func ProjectApiApinamePost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var a ApiItem
	var achou bool
	achou = false
	pos := -1
	vars := mux.Vars(r)

	prj := vars["projectname"]

	body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
	if err != nil {
		panic(err)
	}
	if err := r.Body.Close(); err != nil {
		panic(err)
	}

	if err := json.Unmarshal(body, &a); err != nil {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(400) // unprocessable entity
		if err := json.NewEncoder(w).Encode(err); err != nil {
			panic(err)
		}
	}
	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == prj {

			achou = true

			pos = i

		}
	}
	if achou {

		projetos[pos].Apis = append(projetos[pos].Apis, a)
		json.NewEncoder(w).Encode(a)

		w.WriteHeader(http.StatusOK)

	} else {
		w.WriteHeader(http.StatusBadRequest)
	}

}

func ProjectApiApinameGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var a ApiItem
	var achou bool
	achou = false
	vars := mux.Vars(r)

	prj := vars["projectname"]

	api := vars["apiname"]
	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == prj {

			for j := 0; j < len(projetos[i].Apis); j++ {

				if projetos[i].Apis[j].Name == api {
					achou = true
					a = projetos[i].Apis[j]
				}
			}

		}
	}
	if achou {
		json.NewEncoder(w).Encode(a)

		w.WriteHeader(http.StatusOK)

	} else {
		w.WriteHeader(http.StatusBadRequest)
	}

}
func ProjectApiApinameDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var achou bool
	achou = false
	vars := mux.Vars(r)

	prj := vars["projectname"]

	api := vars["apiname"]
	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == prj {

			for j := 0; j < len(projetos[i].Apis); j++ {

				if projetos[i].Apis[j].Name == api {
					achou = true
					pos := j
					pos++

					projetos[i].Apis[j].Name = ""
					projetos[i].Apis[j].Description = " "
					projetos[i].Apis[j].DisplayName = " "
					projetos[i].Apis[j].CreateTime = time.Time{}
					projetos[i].Apis[j].UpdateTime = time.Time{}
					projetos[i].Apis[j].OpenapiFile = " "
				}
			}

		}
	}
	if achou {
		//json.NewEncoder(w).Encode(a)

		w.WriteHeader(http.StatusOK)

	} else {
		w.WriteHeader(http.StatusBadRequest)
	}
}

func ProjectApiApinamePut(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var a ApiItem
	var achou bool
	achou = false
	vars := mux.Vars(r)
	pos_1 := -1
	pos_2 := -1

	prj := vars["projectname"]

	api := vars["apiname"]

	body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
	if err != nil {
		panic(err)
	}
	if err := r.Body.Close(); err != nil {
		panic(err)
	}

	if err := json.Unmarshal(body, &a); err != nil {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(400) // unprocessable entity
		if err := json.NewEncoder(w).Encode(err); err != nil {
			panic(err)
		}
	}
	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == prj {

			for j := 0; j < len(projetos[i].Apis); j++ {

				pos_1 = i
				if projetos[i].Apis[j].Name == api {
					achou = true
					pos_2 = j

				}
			}

		}
	}
	if achou {

		json.NewEncoder(w).Encode(a)
		projetos[pos_1].Apis[pos_2] = a
		w.WriteHeader(http.StatusOK)

	} else {
		w.WriteHeader(http.StatusBadRequest)
	}

}

/**********************************************************************************************************************************************
*       Project   Handles
*
***********************************************************************************************************************************************
 */
func SearchProjects(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var p ProjectItem
	prjs := searchProjecttDB(url, "Desafio", "Projects", "prj", "api", p, true)
	//json.NewEncoder(w).Encode(projetos)
	json.NewEncoder(w).Encode(prjs)
	w.WriteHeader(http.StatusOK)
}

func AddProject(w http.ResponseWriter, r *http.Request) {
	var p ProjectItem
	var repetido bool
	repetido = false

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
	if err != nil {
		panic(err)
	}
	if err := r.Body.Close(); err != nil {
		panic(err)
	}

	if err := json.Unmarshal(body, &p); err != nil {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(400) // unprocessable entity
		if err := json.NewEncoder(w).Encode(err); err != nil {
			panic(err)
		}
	}
	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == p.Name {

			repetido = true

		}
	}

	if repetido {
		w.WriteHeader(http.StatusConflict)

	} else {
		projetos = append(projetos, p)
		if err := json.NewEncoder(w).Encode(p); err != nil {
			panic(err)
		}
		w.WriteHeader(http.StatusOK)
	}

}

// ************************* Individuals ********************************************************************************************************

func ProjectProjectnameGet(w http.ResponseWriter, r *http.Request) {

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var p ProjectItem
	var achou bool
	achou = false
	param1 := r.URL.Query().Get("name")

	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == param1 {
			achou = true
			p = projetos[i]

		}
	}
	if achou {
		json.NewEncoder(w).Encode(p)

		w.WriteHeader(http.StatusOK)

	} else {
		w.WriteHeader(http.StatusBadRequest)
	}

}

func ProjectProjectnameDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	//var p ProjectItem
	var achou bool
	achou = false
	pos := -1

	param1 := r.URL.Query().Get("name")

	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == param1 {
			achou = true
			pos = i

		}
	}
	if achou {

		projetos[pos].Apis = nil
		projetos[pos].Name = ""
		projetos[pos].CreateTime = time.Time{}
		projetos[pos].UpdateTime = time.Time{}
		projetos[pos].Description = ""
		projetos[pos].DisplayName = ""

		w.WriteHeader(http.StatusOK)

	} else {
		w.WriteHeader(http.StatusBadRequest)
	}
}

func ProjectProjectnamePut(w http.ResponseWriter, r *http.Request) {
	var p ProjectItem
	achou := false
	pos := -1
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
	if err != nil {
		panic(err)
	}
	if err := r.Body.Close(); err != nil {
		panic(err)
	}

	if err := json.Unmarshal(body, &p); err != nil {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(400) // unprocessable entity
		if err := json.NewEncoder(w).Encode(err); err != nil {
			panic(err)
		}
	}
	for i := 0; i < len(projetos); i++ {
		if projetos[i].Name == p.Name {

			achou = true
			pos = i

		}
	}

	if achou {
		projetos[pos].Name = p.Name
		projetos[pos].Description = p.Description
		projetos[pos].DisplayName = p.DisplayName
		projetos[pos].Apis = p.Apis
		projetos[pos].CreateTime = p.CreateTime
		projetos[pos].UpdateTime = p.UpdateTime
		w.WriteHeader(http.StatusOK)

	} else {

		if err := json.NewEncoder(w).Encode(p); err != nil {
			panic(err)
		}
		w.WriteHeader(http.StatusBadRequest)
	}
}
